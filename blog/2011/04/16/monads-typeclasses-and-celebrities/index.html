
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Introduction to Monads and Typeclasses in Haskell - My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="My favorite problems are the ones that you can turn into a mini-lesson on something new. I realized the following problem could make a nice &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://echen.github.com/blog/2011/04/16/monads-typeclasses-and-celebrities">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:echen.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Introduction to Monads and Typeclasses in Haskell</h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-16T03:40:23-07:00" pubdate data-updated="true">Apr 16<span>th</span>, 2011</time>
        
      </p>
    
  </header>


<div class="entry-content"><p>My favorite problems are the ones that you can turn into a mini-lesson on something new. I realized the following problem could make a nice introduction to the Maybe monad and typeclasses in Haskell, so I&#8217;m going to try lessonizing it here.</p>

<h1>Finding Celebrities</h1>

<p>The problem is this: suppose you have a group of people, and you want to find a &#8220;celebrity&#8221; among them, where a celebrity is defined as a person P such that everybody else knows P, but P knows no one. (Note that, by the definition of celebrity, there can be at most one celebrity in a group.) So you&#8217;re given a group of people, a black box oracle that tells you whether person X knows person Y, and you want to efficiently find a celebrity in the group (if such a celebrity exists).</p>

<p>The solution I came up with is the following two-step algorithm:</p>

<ul>
<li><p>Step 1 finds a candidate celebrity. We keep a temporary candidate C and walk through the group: if C knows the current person P under our pointer, then C can&#8217;t be a celebrity, so we change the temporary candidate to be P and move on; otherwise, if C does not know the current person P, then we keep C as our candidate and move to the next person on the list.</p></li>
<li><p>Step 2 checks that our candidate celebrity C is actually a celebrity. We walk through the list of people, and check that for every other person P, P knows C but C does not know P.</p></li>
</ul>


<p>Let&#8217;s code this up now in Haskell. Since the algorithm has two steps, let&#8217;s code up each step individually.</p>

<pre><code>-- Step 1
findCandidate :: [Person] -&gt; (Person -&gt; Person -&gt; Bool) -&gt; Maybe Person
findCandidate [] _ = Nothing
findCandidate (x:[]) _ = Just x
findCandidate (x:y:rest) knows =
    if x `knows` y
        then findCandidate (y:rest) knows
        else findCandidate (x:rest) knows

-- Step2
checkCandidate :: [Person] -&gt; (Person -&gt; Person -&gt; Bool) -&gt; Person -&gt; Maybe Person
checkCandidate [] _ candidate = Just candidate
checkCandidate (x:xs) knows candidate
    | x == candidate = checkCandidate xs knows candidate
    | otherwise      =
        if (x `knows` candidate) &amp;&amp; (not $ candidate `knows` x)
            then checkCandidate xs knows candidate
            else Nothing
</code></pre>

<p>Now how do we combine the first two steps? A first approach might be the following:</p>

<pre><code>badFindCelebrity :: [Person] -&gt; (Person -&gt; Person -&gt; Bool) -&gt; Maybe Person
badFindCelebrity xs knows = checkCandidate xs knows (findCandidate xs knows)
</code></pre>

<p>But this doesn&#8217;t work! There&#8217;s a <em>type mismatch</em> in our definition: <code>checkCandidate</code> takes a <code>Person</code> in its last argument, but <code>findCandidate xs knows</code> returns something of type <code>Maybe Person</code>.</p>

<p>How do we fix this? One approach would be to do some checking of our candidate celebrity: if it&#8217;s <code>Nothing</code>, then don&#8217;t even bother passing it to <code>checkCandidate</code> and just fail immediately; otherwise, extract the person from its <code>Just x</code> wrapper, and pass this extraction to <code>checkCandidate</code>. This works as follows:</p>

<pre><code>messyFindCelebrity :: [Person] -&gt; (Person -&gt; Person -&gt; Bool) -&gt; Maybe Person
messyFindCelebrity xs knows =
    case findCandidate xs knows of
        Nothing -&gt; Nothing
        Just x  -&gt; checkCandidate xs knows x
</code></pre>

<p>This isn&#8217;t too bad, but what if we later want to add some additional checks? For example, instead of finding any old celebrity, we might want to find only celebrities that have recently starred in a movie, in which case we&#8217;d have to modify our algorithm to:</p>

<pre><code>recentMovie :: Person -&gt; Maybe Person
recentMovie x = ...

messyFindCelebrity' :: [Person] -&gt; (Person -&gt; Person -&gt; Bool) -&gt; Maybe Person
messyFindCelebrity' xs knows =
    case findCandidate xs knows of
        Nothing -&gt; Nothing
        Just x  -&gt; case checkCandidate xs knows x of
        Nothing -&gt; Nothing
        Just y  -&gt; recentMovie y
</code></pre>

<h1>Maybe Monad</h1>

<p>Enter the Maybe monad. Instead of forcing us to make these <code>Nothing</code> checks and <code>Just x</code> extractions ourselves, the Maybe monad has a &#8220;chaining&#8221; operator <code>&gt;&gt;=</code> that performs checks and extractions automatically. That is, <code>Nothing &gt;&gt;= f</code> is always <code>Nothing</code>, and <code>Just x &gt;&gt;= f</code> returns <code>f x</code>, so we can rewrite our <code>findCelebrity</code> method as:</p>

<pre><code>findCelebrity :: [Person] -&gt; (Person -&gt; Person -&gt; Bool) -&gt; Maybe Person
findCelebrity xs knows =
    findCandidate xs knows &gt;&gt;= checkCandidate xs knows
</code></pre>

<p>Or, in the sugared <code>do</code> syntax:</p>

<pre><code>findCelebrity :: [Person] -&gt; (Person -&gt; Person -&gt; Bool) -&gt; Maybe Person
findCelebrity xs knows = do
    candidate &lt;- findCandidate xs knows
    celebrity &lt;- checkCandidate xs knows candidate
    return celebrity
</code></pre>

<p>So that&#8217;s the Maybe monad.</p>

<h1>Typeclasses</h1>

<p>Now let&#8217;s see if we can generalize our solution a bit. In our algorithm above, we didn&#8217;t really make use of the fact that we were dealing with <code>Person</code> data types. The only assumption we made was that we could test whether two Persons were equal, in the <code>x == candidate</code> check of <code>checkCandidate</code>*. Thus, if we replace the <code>Person</code> data type in all our type signatures with a data type that supports equality testing, our function will be a bit more general and work just as well.</p>

<p>To do this, we write</p>

<pre><code>findCandidate :: (Eq a) =&gt; [a] -&gt; (a -&gt; a -&gt; Bool) -&gt; Maybe a
checkCandidate :: (Eq a) =&gt; [a] -&gt; (a -&gt; a -&gt; Bool) -&gt; a -&gt; Maybe a
findCelebrity :: (Eq a) =&gt; [a] -&gt; (a -&gt; a -&gt; Bool) -&gt; Maybe a
</code></pre>

<p><code>Eq a</code> simply means that <code>a</code> is a type that supports equality testing, i.e., given any two objects <code>x</code> and <code>y</code> of type <code>a</code>, writing <code>x == y</code> works. So now our <code>findCelebrity</code> function can not only find celebrities in a group of Persons, but also find things like the majority or minority in a group of integers (if we use <code>(&lt;)</code> or <code>(&gt;)</code> as our oracle), and sources or sinks in a graph.</p>

<p>*Note that we can actually get rid of this equality testing assumption, by making <code>findCandidate</code> return a list of rejected persons (in addition to the candidate celebrity) that we check against in <code>checkCandidate</code>.</p>

<h1>An evasive segue</h1>

<p>So there&#8217;s an introduction to the Maybe monad and typeclasses (that maybe you could have discovered yourself!). For just one more quick intro, note that the celebrity question provides a counterexample to the <a href="http://blog.echen.me/2011/03/14/topological-combinatorics-and-the-evasiveness-conjecture">Evasiveness Conjecture</a> on <em>non-monotone</em> graphs, showing why the monotonicity assumption in the conjecture is indeed necessary.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Your Name</span></span>

      








  


<time datetime="2011-04-16T03:40:23-07:00" pubdate data-updated="true">Apr 16<span>th</span>, 2011</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/expository/'>expository</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://echen.github.com/blog/2011/04/16/monads-typeclasses-and-celebrities/" data-via="" data-counturl="http://echen.github.com/blog/2011/04/16/monads-typeclasses-and-celebrities/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2011/03/22/harry-potter-and-the-keyword-chaos-unsupervised-statistically-significant-phrases/" title="Previous Post: Harry Potter and the Keyword Chaos: Unsupervised Statistically Significant Phrases">&laquo; Harry Potter and the Keyword Chaos: Unsupervised Statistically Significant Phrases</a>
      
      
        <a class="basic-alignment right" href="/blog/2011/04/16/what-is-cointegration-2/" title="next Post: Introduction to Cointegration and Pairs Trading">Introduction to Cointegration and Pairs Trading &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2012/01/17/quick-introduction-to-ggplot2/">Quick Introduction to ggplot2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/01/03/introduction-to-conditional-random-fields/">Introduction to Conditional Random Fields</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/10/24/winning-the-netflix-prize-a-summary/">Winning the Netflix Prize: A Summary</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/09/29/stuff-harvard-people-like/">Stuff Harvard People Like</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/09/07/information-transmission-in-a-social-network-dissecting-the-spread-of-a-quora-post/">Information Transmission in a Social Network: Dissecting the Spread of a Quora Post</a>
      </li>
    
  </ul>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2012 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
